Conteúdo do arquivo: ./issues.md
# Lista de Issues e Tarefas

Esta lista organiza as issues do projeto com subtarefas (checklists) e comentários sobre dependências, para que você possa acompanhar o progresso e definir prioridades.

---

## Issue #20: [World] Adicionar Objetos Interativos Básicos  

*Descrição:* Criar objetos interativos simples (por exemplo, itens ou caixas colecionáveis) para testar a mecânica de interação dos jogadores. Esses objetos devem ter estado compartilhado entre clientes (por exemplo, desaparecer quando coletados).  
*Dependências:* Baseado na estrutura do mundo (Issue #3) e sincronização posterior (Issue #19).

- [ ] **Protótipo de Objetos:** Criar modelos básicos de itens/caixas colecionáveis.  
- [ ] **Mecânica de Interação:** Desenvolver a lógica que permite que o objeto seja coletado (e desapareça) quando o jogador interagir.  
- [ ] **Estado Compartilhado:** Implementar a atualização do estado do objeto para refletir a coleta em todos os clientes.  
- [ ] **Integração e Testes:** Validar a integração com o mundo básico e testes individuais de interação.

---

## Issue #19: [Multiplayer] Sincronizar Interações no Mundo  

*Descrição:* Sincronizar, via servidor, as interações dos jogadores com os objetos interativos. Ao interagir (por exemplo, ao coletar um item), o estado do objeto deve ser atualizado de forma consistente para todos os clientes.  
*Dependências:* Depende da sincronização de posições (Issue #9) e da existência dos elementos interativos (ver Issue #20 e #18).

- [ ] **Comunicação Server-Cliente:** Criar endpoints ou rotinas no servidor para receber e distribuir eventos de interação.  
- [ ] **Atualização Consistente:** Garantir que, ao coletar um item, o objeto seja removido ou alterado para todos os clientes.  
- [ ] **Integração com Sincronização:** Conectar a lógica de interação com o sistema de sincronização (ver Issue #9).  
- [ ] **Validação e Testes:** Testar a sincronização em cenários com múltiplos clientes conectados.

---

## Issue #18: [World] Adição de Elementos Interativos Simples  

*Descrição:* Adicionar objetos simples no mundo com os quais os jogadores possam interagir, como botões que mudam de estado/cor, itens que podem ser coletados e portas que abrem ou fecham.

- [ ] **Definição de Elementos:** Listar e definir os tipos de elementos interativos a serem implementados.  
- [ ] **Implementação dos Comportamentos:** Desenvolver scripts para alterar o estado (ex.: mudança de cor, desaparecimento ou abertura).  
- [ ] **Integração com o Mundo:** Adicionar os elementos ao cenário e associar eventos de interatividade.  
- [ ] **Teste de Funcionalidades:** Realizar testes unitários e de integração para validar o funcionamento de cada elemento.

---

## Issue #17: [UI] Implementar HUD Básico  

*Descrição:* Desenvolver uma interface de usuário básica (HUD) sobreposta ao canvas 3D utilizando HTML/CSS. Essa HUD deve exibir a lista de jogadores online, um chat simples e indicadores de status (como permissões de sensores, por exemplo).

- [ ] **Layout e Design:** Esboçar e implementar o layout da HUD (HTML/CSS).  
- [ ] **Lista de Jogadores:** Criar um componente que atualiza em tempo real a lista de jogadores conectados.  
- [ ] **Chat Simples:** Desenvolver a funcionalidade de chat, inclusive com publicação de mensagens.  
- [ ] **Indicadores de Status:** Adicionar indicadores (ex.: status de conexão, permissões) conforme especificado na arquitetura.  
- [ ] **Integração com Backend:** Garantir que a HUD responda às mudanças de estado enviadas pelo servidor.

---

## Issue #16: [Optimization] Otimizar Carregamento Dinâmico do Mundo  

*Descrição:* Refinar o sistema de carregamento do mundo para suportar mapas grandes, implementando o carregamento/descarregamento dinâmico de partes (chunks/tiles/assets) conforme a movimentação do jogador.  
*Dependências:* Baseado na estrutura do mundo (Issue #3) e estratégia de carregamento definida (Issue #2).

- [ ] **Revisão da Implementação Atual:** Analisar o carregamento do mundo definido na Issue #3.  
- [ ] **Lógica de Streaming:** Implementar detecção de movimento do jogador e carregamento dinâmico de chunks ou tiles.  
- [ ] **Gerenciamento de Memória:** Otimizar a liberação de assets não utilizados e minimizar os tempos de carregamento.  
- [ ] **Testes de Performance:** Realizar benchmark em mapas grandes e ajustar a implementação.

---

## Issue #15: [Optimization] Implementar LOD para Avatares  

*Descrição:* Implantar o Nível de Detalhe (LOD) para reduzir a carga de renderização de avatares distantes, substituindo modelos complexos por versões simplificadas.

- [ ] **Análise dos Modelos:** Verificar a complexidade dos modelos atuais e identificar gargalos na renderização.  
- [ ] **Criação de LODs:** Desenvolver versões simplificadas dos avatares para serem utilizadas quando distantes da câmera.  
- [ ] **Integração no Pipeline:** Ajustar o sistema de renderização para trocar modelos conforme a distância.  
- [ ] **Validação de Performance:** Comparar a performance antes e depois da implementação do LOD.

---

## Issue #14: [Optimization] Analisar Performance Inicial da Cena  

*Descrição:* Configurar e utilizar ferramentas de profiling para analisar a performance da cena com múltiplos jogadores (mesmo que simulados), identificando os principais gargalos em CPU, GPU, memória e rede.

- [ ] **Configuração de Ferramentas:** Instalar e configurar ferramentas como Stats.js, Chrome DevTools Performance e SpectoGL.  
- [ ] **Coleta de Dados:** Executar testes em cenário com múltiplos jogadores e coletar métricas de performance.  
- [ ] **Análise dos Gargalos:** Identificar e documentar problemas em CPU, GPU, memória ou rede.  
- [ ] **Documentação e Plano de Otimização:** Criar um relatório com sugestões e prioridades para otimizações futuras.

---

## Issue #13: [Input] Integrar Sensor de Orientação (Magnetômetro)  

*Descrição:* Usar o magnetômetro do dispositivo para funcionalidades como orientar um minimapa ou influenciar a câmera.  

- [ ] **Verificação da API:** Confirmar a disponibilidade da API de magnetômetro nos dispositivos alvo.  
- [ ] **Implementação da Funcionalidade:** Desenvolver a utilização dos dados do magnetômetro para melhorar a experiência (ex.: ajuste do minimapa).  
- [ ] **Permissões e Fallback:** Implementar solicitações de permissão e criar comportamentos alternativos caso o sensor não esteja disponível.  
- [ ] **Testes Cruzados:** Validar o funcionamento em diferentes dispositivos e navegadores.

---

## Issue #12: [Input] Integrar Sensores de Movimento (Giroscópio/Acelerômetro)  

*Descrição:* Permitir que o usuário controle a câmera ou execute ações por meio dos sensores de movimento do dispositivo.

- [ ] **Detecção de Suporte:** Verificar se a API dos sensores de movimento está disponível no dispositivo.  
- [ ] **Implementação de Controles:** Mapear os dados dos sensores para ações de controle (ex.: rotação da câmera).  
- [ ] **Permissão e Fallback:** Solicitar permissões necessárias e implementar soluções caso o sensor não esteja disponível.  
- [ ] **Validação de Usabilidade:** Realizar testes e ajustes para garantir uma experiência fluida.

---

## Issue #11: [Input] Integrar API de Gamepad do Navegador  

*Descrição:* Integrar a API de gamepad para permitir controle do jogo via joystick ou gamepad.

- [ ] **Detectar Disponibilidade:** Verificar a existência e conectividade da API de gamepad no navegador.  
- [ ] **Mapeamento de Controles:** Implementar a detecção do estado do gamepad e vincular aos comandos do jogo.  
- [ ] **Feedback de Conexão:** Exibir mensagens ou avisos caso o gamepad não esteja conectado.  
- [ ] **Testes Multi-Plataforma:** Testar com diferentes gamepads e em variados navegadores.

---

## Issue #10: [Input] Criar Camada de Abstração de Entrada  

*Descrição:* Refatorar o sistema de input para que diversas fontes (teclado, mouse, toque, gamepad e sensores) disparem ações genéricas, simplificando a lógica do jogo.

- [ ] **Mapeamento de Inputs:** Levantar os eventos de entrada atuais e definir ações genéricas (por exemplo, 'mover_frente', 'interagir').  
- [ ] **Refatoração do Código:** Ajustar o sistema para disparar eventos genéricos em vez de ler os eventos brutos.  
- [ ] **Documentação:** Documentar a nova camada de abstração para facilitar futuras integrações e adaptações.  
- [ ] **Teste de Extensibilidade:** Validar que a nova abordagem facilita a integração de novos métodos de controle.

---

## Issue #9: [Multiplayer] Sincronizar Posições de Jogadores  

*Descrição:* Implementar a sincronização de posição e rotação dos jogadores, enviando dados entre cliente e servidor para atualizar a representação visual entre todos.

- [ ] **Envio de Dados:** Configurar o cliente para enviar dados de transformação (posição e rotação) para o servidor.  
- [ ] **Broadcast no Servidor:** Implementar o repasse desses dados para os demais clientes conectados.  
- [ ] **Interpolação/Extrapolação:** Aplicar técnicas para suavizar os movimentos dos jogadores remotos.  
- [ ] **Integração com Conexão:** Certificar que essa sincronização se encaixa com a lógica de conexão e desconexão (Issue #8).

---

## Issue #8: [Multiplayer] Configurar Servidor Node.js Básico  

*Descrição:* Configurar o ambiente do servidor para lidar com múltiplos clientes, tratando conexões e desconexões de forma básica.

- [ ] **Setup do Ambiente:** Configurar o Node.js para o servidor do jogo.  
- [ ] **Lógica de Conexão:** Implementar handlers para `on connection` e `on disconnect`, gerenciando clientes.  
- [ ] **Lista de Clientes:** Manter uma lista atualizada dos clientes conectados, possibilitando broadcast.  
- [ ] **Testes de Comunicação:** Realizar testes iniciais de conexão para validar a comunicação básica.

---

## Issue #7: [Multiplayer] Definir Tecnologia de Rede  

*Descrição:* Pesquisar e decidir qual tecnologia e biblioteca utilizar para o multiplayer, considerando aspectos como facilidade de uso, performance, escalabilidade e latência.

- [ ] **Pesquisa de Tecnologias:** Revisar opções como WebSockets, WebRTC, Socket.IO, Colyseus, uWebSockets.js, entre outras.  
- [ ] **Avaliação de Trade-offs:** Listar prós e contras de cada alternativa em termos de requisitos do projeto.  
- [ ] **Documentação da Escolha:** Documentar a decisão final e as justificativas técnicas para a opção adotada.  
- [ ] **Revisão Arquitetural:** Confirmar que a tecnologia escolhida atende aos requisitos do multiplayer em tempo real.

---

## Issue #6: [Input] Adicionar Controles de Toque (Mobile)  

*Descrição:* Implementar controles via toque para dispositivos móveis, como um joystick virtual ou gestos de arrasto, para movimentação e rotação da câmera.

- [ ] **Design de UI Mobile:** Criar um layout intuitivo e responsivo para os controles de toque.  
- [ ] **Implementação do Joystick Virtual:** Desenvolver a lógica para detectar toques e arrastos, convertendo-os em comandos de movimentação.  
- [ ] **Integração:** Conectar os controles de toque à camada de abstração de input (Issue #10).  
- [ ] **Testes em Dispositivos:** Validar a usabilidade em diferentes tipos de dispositivos móveis.

---

## Issue #5: [Input] Adicionar Controles de Teclado/Mouse  

*Descrição:* Permitir a movimentação do jogador e controle da câmera utilizando teclado (WASD ou setas) e mouse.

- [x] **Implementação de Movimentação:** Codificar a lógica de movimentação usando as teclas WASD ou setas.  
- [x] **Controle de Câmera:** Integrar o uso do mouse para rotação e direcionamento da câmera, possibilitando uma visão livre.  
- [x] **Integração com Mundo Básico:** Garantir que o movimento se integre com o cenário criado na Issue #3.  
- [x] **Testes e Ajustes:** Validar a responsividade e ajustar a sensibilidade dos controles.

---

## Issue #4: [Player] Implementar Avatar 3D Básico  

*Descrição:* Adicionar um avatar 3D simples para cada jogador, utilizando objetos primitivos ou modelos leves (GLTF/GLB).

- [x] **Seleção ou Criação do Modelo:** Escolher entre um modelo básico (ex.: BoxGeometry, SphereGeometry) ou importar um modelo simples.  
- [x] **Posicionamento Inicial:** Definir e aplicar o ponto inicial do avatar no mundo, conforme a estrutura definida na Issue #3.  
- [x] **Integração com Sistemas de Movimento:** Conectar o avatar ao sistema de input e sincronização de movimentação.  
- [x] **Teste Visual:** Validar que o avatar seja exibido corretamente e responda às interações.

---

## Issue #3: [World] Implementar Mundo Básico para Testes  

*Descrição:* Desenvolver um protótipo do mundo de teste, com um ambiente amplo para validação dos sistemas de movimentação e interação.

- [x] **Criação do Mundo:** Implementar uma esfera gigante, essa esfera deverá ser gigante, tão grande que pareça como um plano na visão do jogador, deverá ter escala planetaria.  
- [x] **Marcadores Visuais:** Adicionar cubos ou outros marcadores que ajudem a definir a escala e facilitam os testes de movimentação.  
- [x] **Integração Inicial:** Garantir que a movimentação do jogador seja testável neste ambiente.  
- [x] **Documentação para Atualizações:** Anotar potenciais melhorias e escalabilidade para futuras implementações.

---

## Issue #2: [World] Definir Estratégia de Carregamento do Mundo Explorado  

*Descrição:* Pesquisar e definir abordagens para implementar um mapa grande, considerando técnicas como tiles, chunks, streaming ou geração procedural.  
*Dependências:* Essencial para otimização e escalabilidade (ligação com Issue #16).

- [x] **Pesquisa de Abordagens:** Investigar técnicas (tiles, chunks, streaming, procedural) para carregamento de mapas grandes.  
- [x] **Avaliação de Trade-offs:** Analisar performance, uso de memória e tempos de carregamento para cada abordagem.  
- [x] **Seleção da Estratégia:** Escolher a solução mais viável para o projeto com base na avaliação.  
- [x] **Documentação Técnica:** Registrar a decisão, justificativas e requisitos para a implementação.

---

## Issue #1: [Core] Inicializar Projeto com Vite e Three.js  

*Descrição:* Configurar a base do projeto utilizando Vite e Three.js, garantindo a operacionalidade inicial da cena, câmera e renderizador.

- [x] **Setup Inicial:** Configurar o template Vite integrado com Three.js.  
- [x] **Limpeza do Boilerplate:** Remover códigos não utilizados e estabelecer padrões iniciais de organização.  
- [x] **Validação dos Elementos Básicos:** Confirmar que a cena, a câmera e o renderer estão funcionando corretamente.  
- [x] **Documentação do Projeto:** Estabelecer diretrizes de arquitetura e organização para futuras implementações.
---------------------------------
Conteúdo do arquivo: ./.vscode/settings.json
{
  "CodeGPT.apiKey": "CodeGPT Plus Beta"
}---------------------------------
Conteúdo do arquivo: ./output.txt
---------------------------------
Conteúdo do arquivo: ./Arquitetura.puml
@startuml Arquitetura Cliente - Projeto Mundo

!theme materia

' ----- Core Three.js & Orquestração -----
class Experience {
  +camera: Camera
  +renderer: Renderer
  +scene: THREE.Scene
  +world: World
  +time: Time
  +sizes: Sizes
  +resources: Resources
  +config: Config
  +inputManager: InputManager
  +networkManager: NetworkManager
  +uiManager: UIManager
  +audioManager: AudioManager ' Opcional, mas comum
  +update() ' Main loop tick
}

class Camera {
  +instance: THREE.PerspectiveCamera
  +controls: OrbitControls | PointerLockControls | DeviceOrientationControls ' Controles variados
  +resize()
  +update()
}

class Renderer {
  +instance: THREE.WebGLRenderer
  +resize()
  +update() ' Render frame
}

class World {
  +experience: Experience ' Referência para acesso a outros módulos
  +environment: Environment?
  +players: Map<playerId, Player> ' Coleção de jogadores (locais e remotos)
  +staticObjects: THREE.Object3D[] ' Objetos do cenário
  +interactiveObjects: Map<objectId, InteractiveObject>
  +initWorld()
  +addPlayer(playerData, isLocal)
  +removePlayer(playerId)
  +updatePlayer(playerId, state)
  +update() ' Atualiza entidades do mundo
  +loadChunk(coords) ' Para streaming/mundo aberto
  +unloadChunk(coords) ' Para streaming/mundo aberto
}

class Environment {
  +sunLight: THREE.DirectionalLight
  +ambientLight: THREE.AmbientLight
  +environmentMap: object ' Textura de ambiente (HDR/EXR)
  +load()
}

' ----- Utilitários Core -----
class Time <<EventEmitter>> {
  +start: number
  +current: number
  +elapsed: number
  +delta: number
  +tick()
  +on(event, callback)
}
class Sizes <<EventEmitter>> {
  +width: number
  +height: number
  +pixelRatio: number
  +aspectRatio: number
  +resize()
  +on(event, callback)
}
class Resources <<EventEmitter>> {
  +items: object ' Assets carregados (modelos, texturas, etc.)
  +toLoad: number
  +loaded: number
  +load(sources) ' Carrega lista inicial de assets
  +lazyLoad(asset) ' Carrega assets sob demanda (mundo aberto)
  +on(event, callback) ' 'ready', 'progress', 'assetLoaded'
}
class Config {
  +debug: boolean
  +worldSize: number
  +playerSettings: object
  +networkSettings: object
}

' ----- Gerenciadores de Lógica -----
class InputManager <<EventEmitter>> {
  +setupEventListeners() ' Teclado, Mouse, Touch, Gamepad, Sensores (Giroscópio, Acelerômetro, Bússola)
  +processInput() ' Normaliza e dispara eventos de ação
  +on(event, callback) ' Ex: 'action:move', 'action:look', 'action:jump', 'action:interact'
  +trigger(event, data) ' Dispara ações normalizadas
}

class NetworkManager <<EventEmitter>> {
  +socket: WebSocket | WebRTC ' Instância da conexão
  +connect(url)
  +disconnect()
  +send(type, payload) ' Envia dados ao servidor (ex: input local, posição)
  +handleMessage(message) ' Processa mensagens do servidor
  +on(event, callback) ' 'connected', 'disconnected', 'playerJoined', 'playerLeft', 'worldState', 'entityUpdate'
}

class UIManager {
  +hudElement: HTMLElement ' Elemento DOM para o HUD
  +updatePlayerList(players)
  +displayChatMessage(message)
  +showInteractionPrompt(show)
  +updateStatus(status) ' Ex: Conectado, Carregando...
}

class AudioManager {
    +playSound(soundName, position?) ' Sons 3D posicionais
    +playMusic(trackName)
    +setListener(camera) ' Para áudio posicional
}

' ----- Entidades do Mundo -----
abstract class BaseEntity {
  +id: string | number
  +mesh: THREE.Object3D
  +update(deltaTime)
}

class Player extends BaseEntity {
  +isLocalPlayer: boolean
  +state: object ' Posição, rotação, etc. (recebido do servidor para remotos)
  +update(deltaTime) ' Interpola/Extrapola movimento para jogadores remotos
  +applyLocalInput(inputActions) ' Apenas para jogador local
}

class InteractiveObject extends BaseEntity {
    +interactionType: string ' 'collect', 'activate', 'open'
    +onInteraction(player)
}

' ----- Relacionamentos -----

' Experience orquestra tudo
Experience o--> Camera
Experience o--> Renderer
Experience o--> World
Experience o--> Time
Experience o--> Sizes
Experience o--> Resources
Experience o--> Config
Experience o--> InputManager
Experience o--> NetworkManager
Experience o--> UIManager
Experience o--> AudioManager

' Componentes Core interagem
Renderer ..> Experience : "needs scene & camera"
World o--> Environment
World "1" *-- "0..*" Player : "manages"
World "1" *-- "0..*" InteractiveObject : "manages"
World ..> Resources : "requests assets"
World ..> Time : "uses delta time"
World ..> Experience : "accesses other modules"

' Gerenciadores interagem com Core, Mundo e entre si (idealmente via eventos)
InputManager ..> Experience : "listens to DOM events via Sizes"
InputManager ..> Player : "(Local) Player listens for 'action:*' events"
NetworkManager ..> World : "updates world based on server messages (add/remove/update players/objects)"
NetworkManager ..> Player : "sends local player state"
NetworkManager ..> UIManager : "updates UI based on network events (connect/disconnect)"
World ..> NetworkManager : "notifies NetworkManager of local interactions to send"
UIManager ..> World : "may query world state for display"
AudioManager ..> Camera : "uses camera as listener"

' Entidades são parte do Mundo
World ..> BaseEntity : "adds entities to scene"
Player ..> BaseEntity
InteractiveObject ..> BaseEntity

' Recursos são usados por muitos
Environment ..> Resources
BaseEntity ..> Resources

' Utilitários são usados por muitos
Experience ..> Time
Experience ..> Sizes
Experience ..> Resources
World ..> Time
BaseEntity ..> Time

' ----- Notas Específicas do Projeto Mundo -----

note right of Experience
  **Arquitetura Cliente-Servidor:**
  Este diagrama representa o **cliente**.
  A lógica de jogo autoritativa, física,
  validação e persistência residem no **servidor**
  (não mostrado aqui).
end note

note left of NetworkManager
  **Sincronização de Estado:**
  NetworkManager recebe atualizações do servidor
  e as repassa para `World` atualizar os `Player` remotos
  e outros objetos sincronizados. O `Player` local envia
  seu input/estado para o servidor via NetworkManager.
end note

note bottom of World
  **Mundo Aberto / Streaming:**
  `World` é responsável por carregar/descarregar
  partes do cenário (`loadChunk`/`unloadChunk`)
  e solicitar assets via `Resources.lazyLoad`
  conforme o jogador se move, para gerenciar
  memória e performance.
end note

note top of Resources
  **Gerenciamento de Assets:**
  `Resources.lazyLoad` é crucial para
  carregar assets de forma assíncrona
  e sob demanda, essencial para mundos grandes.
end note

note left of InputManager
  **Abstração de Input:**
  InputManager captura inputs brutos (teclado,
  mouse, touch, gamepad, **sensores**) e dispara
  eventos de **ação** normalizados (ex: 'action:move').
  O `Player` local escuta essas ações.
end note

note right of Player
  **Representação do Jogador:**
  A classe `Player` representa tanto o jogador
  local quanto os remotos. A lógica de `update`
  difere: local aplica input, remoto interpola
  dados recebidos do servidor via `NetworkManager` -> `World`.
end note

@enduml---------------------------------
Conteúdo do arquivo: ./README.md
# Mundo

Este projeto, "Mundo", visa criar uma experiência 3D de mundo aberto, explorável e multiplayer, acessível diretamente pelo navegador web. Utilizando **Three.js** e tecnologias web modernas (como Vite), o objetivo é construir um ambiente virtual compartilhado, otimizado para performance e com suporte a diversas formas de interação.

## Estrutura do Projeto

A organização do projeto busca clareza, modularidade e facilidade de manutenção:

- **`public/`**: Contém os arquivos estáticos da aplicação.
  - **`index.html`**: Ponto de entrada da aplicação web.
  - **`assets/`**: Modelos 3D (mapa, avatares, objetos), texturas, arquivos de áudio e outros recursos.
- **`src/`**: Código-fonte principal da aplicação.
  - **`Experience/`**: Orquestra a cena 3D principal: câmera, renderer, loop de atualização e elementos centrais da experiência.
  - **`World/`**: Lógica relacionada ao ambiente do jogo, carregamento de cenário, elementos estáticos e dinâmicos.
  - **`Components/`**: Entidades dinâmicas da cena, como `Player` (representação do avatar do usuário) e outros elementos interativos ou NPCs básicos.
  - **`Managers/`**: Gerenciadores de sistemas específicos:
    - `InputManager`: Captura e processa entradas do usuário (teclado, mouse, touch, gamepad, sensores).
    - `NetworkManager`: Gerencia a comunicação com o servidor para a funcionalidade multiplayer (conexão, sincronização).
    - `UIManager`: Controla a interface do usuário (HUD) sobreposta à cena 3D.
    - `WorldManager`: Responsável pela lógica de carregamento, streaming ou gerenciamento de partes do mundo.
  - **`Config/`**: Arquivos de configuração, constantes e definições globais.
  - **`Utils/`**: Funções utilitárias reutilizáveis em diferentes partes do projeto.
- **`node_modules/`**: Dependências do projeto (gerenciadas pelo npm/yarn).
- **`package.json`**: Configuração do projeto Node.js, scripts e lista de dependências.
- **`vite.config.js`**: Configuração específica do Vite para o servidor de desenvolvimento e build de produção.
- **`(backend)/`** (Opcional/Separado): Pode haver um diretório ou repositório separado para o código do servidor Node.js responsável pelo multiplayer.

## Dependências e Instalação

### Pré-requisitos

- **Node.js** (Verifique a versão recomendada no `package.json` ou use LTS)
- **npm** ou **yarn** como gerenciador de pacotes

### Passos para Instalação (Frontend)

1. Clone o repositório:

   ```bash
   git clone https://github.com/rafatrinity/mundo.git
   ```

2. Navegue até o diretório do projeto:

   ```bash
   cd mundo
   ```

3. Instale as dependências:

   ```bash
   npm install
   # ou
   # yarn install
   ```

*(Nota: Se houver um backend separado, siga as instruções de instalação dele também.)*

## Execução do Projeto

### Modo Desenvolvimento (Frontend)

Para iniciar o servidor de desenvolvimento Vite com hot-reload:

```bash
npm run dev
# ou
# yarn dev
```

Acesse a aplicação no endereço fornecido pelo Vite (geralmente algo como `http://localhost:5173`, mas verifique a saída do terminal).

### Modo Produção (Frontend)

Para criar uma versão otimizada para deploy:

1. Gere o build:

   ```bash
   npm run build
   # ou
   # yarn build
   ```

   Os arquivos otimizados estarão na pasta `dist/`.
2. Para testar o build localmente (simulando um servidor de produção):

   ```bash
   npm run preview
   # ou
   # yarn preview
   ```

   Acesse no endereço fornecido pelo Vite.

*(Nota: Para a funcionalidade multiplayer completa, o servidor backend também precisa estar em execução.)*

## Funcionalidades Planejadas / Principais

O desenvolvimento está organizado em torno das seguintes funcionalidades chave (veja as [Issues](https://github.com/rafatrinity/mundo/issues) para detalhes e progresso):

- **Mundo Vasto e Explorável**: Implementação de um mapa grande, utilizando estratégias eficientes de carregamento/streaming (ex: chunks, tiles) para otimização web.
- **Multiplayer em Tempo Real**: Conexão de múltiplos jogadores via WebSockets (ou tecnologia similar), com sincronização de posição, rotação e interações básicas.
- **Avatar do Jogador**: Representação 3D do jogador na cena, com movimentação controlada pelo usuário.
- **Controles Flexíveis**: Suporte a múltiplos métodos de entrada: teclado/mouse, toque (mobile), gamepad e exploração do uso de sensores de dispositivos móveis (giroscópio, acelerômetro, bússola).
- **Interface de Usuário (HUD)**: Exibição de informações relevantes na tela (lista de jogadores, chat básico, status, etc.) usando HTML/CSS sobreposto ao canvas 3D.
- **Otimização Web**: Foco contínuo em performance (análise de gargalos, LOD para avatares, carregamento eficiente de assets) para garantir uma experiência fluida no navegador.
- **Interação com o Mundo**: Adição gradual de elementos no ambiente com os quais os jogadores possam interagir.

*(Dica: Adicione capturas de tela ou GIFs do projeto em desenvolvimento aqui para enriquecer esta seção!)*

## Contribuição

Interessado em contribuir para o "Mundo"? Ótimo!

- **Reportar Problemas**: Encontrou um bug ou tem uma ideia? Abra uma [Issue](https://github.com/rafatrinity/mundo/issues).
- **Enviar Pull Requests**:
  1. Faça um fork do repositório `rafatrinity/mundo`.
  2. Crie uma branch para sua funcionalidade ou correção (ex: `git checkout -b feature/nova-interacao` ou `fix/bug-movimento`).
  3. Faça suas alterações e commit (`git commit -m 'feat: Adiciona interação X'`).
  4. Garanta que o código segue os padrões (use `npm run lint` se configurado).
  5. Envie um *Pull Request* para a branch principal (`main` ou `master`) do repositório original com uma descrição clara do que foi feito.

## Licença

Este projeto está licenciado sob a [Licença MIT](LICENSE). (Certifique-se de ter um arquivo `LICENSE` no seu repositório contendo o texto da licença MIT).

[![](https://img.plantuml.biz/plantuml/dsvg/bLbDRoEv4RthLp0wh3wYaHFiJHXursiBCrxOuu7jmGO80eZgfYMEkvkzJRR7dYG_Pf93a01xckIIg_vONXNPtMp9NY1p63NP9BlugkhLXx-tJbQkpZDnKlrSQwTSNKbnccbLE2LUYVUL-QYS4PTraPh1u3Tkgt8bSkbKfULWC1Alw9yuDPKIjzjAgVb7AxuHLpXCMLV9tJzsVpT-qI39fBLY-LXYhoeI9Vuy4EAtYSnL9HVYb7zffb95gYfLBSHrUA9PcwX2BSJjs-lbSdv30vhzPAeiNOYVw8V6JkUq2F_p7lrPsOMueHz_iZLrbT3STVF8CfZYJcyW0__IZ2xAsbtAGcv8ZlDeH6yBvV3X-_RzkzwOLjIwVVdXF9gNTQfD--ea6ecHk2eJRGgPpG2m5Od9wvpFAbFWFPvWnQNKXSYCAONJoVtWhuC0gWVF0weBw1JmDbYzLvKjLUBqW-emnerTPJ80SLMjjJiDG_4NyTvegBwwCCbzD7kc7dIYhaXnJZf8sRuRYV2eh7YGi8hKD5W3zl4ala4dSAFPvqN-IQtVNCJAV-umVDal4NSLxjMTpSRW3rQjiIrYmwETTwhQ_Qj8j1Ib17GIfc2DaCBKk8mL-UvhMcV-Agfuq9KfSjmTntI3x-XbcSad8Bo0RihNVd2UpiHxVZfcU3BbtI1LugFP021SHumpaqXjXHALoeqpbYzd2TtaQlqH2hCD77xuxTaV_qH6iYQ7j28r0awm-r9fuo64qYHhkTrD4XaUa4Jd-okE_Jxj630FhanJB_dON-LCEZaJsi8SP3RngiZDW-ejEayZnUozcGcwajhNt8chPQO_Im4OTIfJnHVAcMMmCZCoFTtMnVquCQPABMrvJse2foYPws9pn6k5NAlAyPQw-7ytjGOJgTIRZQsB2xtPkaO1PxeY1oBVv7b6Ab-JC_JMdKHpUuO3NIo4LmR4kbMFJBImY72E4kEtPzT7opzSJne0lByq5Fl1wKmxrhVrV1kpAZ6UUFrw-O2ZbhbsKFNnSRWCCVn257M-ziwKr5N5fjnDgKoMLgNnLAeo9-C9OXnl9AOOA_hGJC0eihLCxabIBmXpxGkIVDAfsyP7RfL7hvifzQFAhebXubd917Om7RF2hydKSlqBSY7ivJRIpecroe609N0YTuMpvWPu63iJpciEJyebS_wqCnVGLYmOQKyTp8o356INf_viaMceHy09GKGPcmD_cxV8pqzqy9Yduar-ZR1cZHsvB5890IFBVWaG73629wHFevaObPNP041BptpW1GizQb7pmT0ZbAfrZVYuDk0oMRI1bvJTqnux_Oro3ixM8Xf5p8DNaO6_0TaJ7tjw11GNkwyRdSYUdSUH-2LxHmvJyeiBW8iyeR9CERSAHwHc9YvDRTLCt9ewsSx46yIEKeAdRbHXFJE_WTFQPFUrr5XzagWCeUBVkK9Sc8aVTlz5dCWaOmmCAMomKFoDTwRA0w-9L5kEBAm5mpVowT3Bsba-Bg0CPfe5iIphnWyHzE-ZuSSwBwDXm_uZjiTARm1Fym5mhgJ3pu8y9CH_SCsYaJMLjkF2VYhp4iH83XJy5d7wXX-H8U3v-lOKtpb7CD_zZICh31E9XdeCbyPp0QMFwyg74Y3KJFdWXt0-Taybb5FA9t8P1WKaIaUH7qeZhAeUD6n4Z1NGuZnDK2X5rbGQgnbXFcqBnyZK9VI3cunp_yinmMjD2l0opHKSUvfpVyLtWh1m4Y3V2U_7tlP_HFOKZo_KdQEHTnUAX3IYeEUUFd0u77NOjvcYHtbRfyjC-QpZxUtbHHWG9Fx9YBEhIv--6F7smzb-42Rx3u7ODe3Jy7GhtJukZF_MV6gp15C0fxnqOvgDmZTTehPZop-DqO8h00HxLo0fiD5yFk_krajrwNg1BcuCY8kOiKZVmHEz4kdhtz7PDmRA-VQC9patrhRRUbbZSemY8xcdhHF_XfWi-FtOrnPj7h3xGa9qXsKn_IpZH8JBdK0ySas530A3lyWFqgebwoy43_0y5e3Lu0GT5GBNxNx-5kL075qfQ4SviLUQG8217ppp8P-4-LKzBkOCAufVxni_c8dAE1aUALw9CH8PjOQTnoRlJIXEGm-aPB-6PPIWlgFb8m2X9m6IqjuI-OWkkms7SV0ko-o9HVSyoIvxmXR6zdDIgWBbJdo0T-WEcOFKzIMGuaJO5BUWabOvxBzPXiqDRpu4RpGGOEGtcoAo_-0wlIpi6faIsqxkITsRo60KLnUcANw5gv7EnczUlJfk2jtzwRRSsN_XQzlzMIvnzoTzeNjuSbFg7eZYwztzwLwvk_zohzRTVzrLk_jlOWOWn4x1Bg0Du1toMQ-vZSe7RNKudn_7o2x4i50AQkTcWFX6U0SV3dp9nv-9alamFVpzK4oXk-7lvlFfi74pd9MpC7Ru_Bf3eplSGl9rsINULufrRqEE5g_Z51rBa7nGCW3F4jIjY9VqhoeJ2bDORDmM0YC5hJFwDB3hvqejSDGpO2ndWS4KrLU0rcenrgcIMSwb1WNKa9PC1hsKwb2AZCdKYX1jU9lb4zZQXeVxEu37lcniPfgZxk3XJUOo7OKZXuEzr8EEyj0GQ4n8Ld0S5MjuFTHTC8CHD3w88NL3_NhaAzGZlqM4-7VasT5EdlrE9x9bMc7-2Ljz0VlijYvWHo9-EE_a2sblWzeuP0n7NV8mYVM_zmaoT-FqdLO7UPcv2p96TCSw8lc7Wqwm7egvV1Amp-efuCWtOtM4p60uwCLfsXnQIutXUe-3UGTjgeeDiekUbZeT87CSt0JIw8OHNvE5fy2Qao6w8abFVZqS17NqDmmE7N9lmO3wEgXkhGbYr9QpnX8Np6jDyIWkzNlEEuWawx_0gRtQ-wMJEwzfl7r_xe2U-n_gKyM-G3pNng5tYEjMBAaktlroXog9qvPUjxQ9JJ0X9IegjCbgkgyZuasdptHzNzs4j60ndMBDqf8cjTnKCgSaeGJZK1CGAUTqclWjq-aSAqz45Yest-X2ELexKsbgQJt8cRZR_OB4Iywmz065HngQmt1H-2UCARJZgAf7MOlw11zeKXGMPLpG-jnGRALY5w9FvWCOlA0xXfjcoBZfeWSzsUdqHXS9b8-If-t7uNOuojzqpyKuKqBD5ZfLeMhgLmfKhnCcaie9pc1MhCLLkmskQiNA6_GgIejKqsWqePzdM-5WM7DnrMtoZawz96hTMbNxgkT8iUnD_jycSqJD_QiSOBGspY5I0AMcSJwTUfivuGQ2E18tJS_COzDSQ_TFqW_YjjrzUL0PEq3earH7SF_c6LkO0tfzIZ5UjJswrT4gwjYj9Wm92cjavWwWXHO7tMNLUiYyQOcii9fwzgXWWMERDLf52IbNZu1a4s8aoPAhVFUregX7naRxgDryW8ip9O4I_srWEcrYhSzpOJE-FHHmUKOu0YcfQkxea2GaR82bkLVAh9jpAsVt2ojU1WJQdWuoTYmkscDyTzGAE2Ao8_kYuU_ziG8-lkx-4eCFytilVIzq9x9a6c3Zic9TrMIMOnVQ9eIYRvmutpZPD8qJybBVEfbE9rtZW-xJjJwcKo_1T1er7kXyjT_pc12N79g_JMgG3WLwsxGm3Y1eMSxlvTjVjumL433YHsyl7eCJNzUfs4bRZdEITDvQ69PxQNwk_Oksq9dtsM_bam6oqrJVmO0MOQCiCrh26C_2PX_3gPwYvOnAKwNr-CPxGz-rLm8fRt3E68xlyLZdsVy0)](https://editor.plantuml.com/uml/bLbDRoEv4RthLp0wh3wYaHFiJHXursiBCrxOuu7jmGO80eZgfYMEkvkzJRR7dYG_Pf93a01xckIIg_vONXNPtMp9NY1p63NP9BlugkhLXx-tJbQkpZDnKlrSQwTSNKbnccbLE2LUYVUL-QYS4PTraPh1u3Tkgt8bSkbKfULWC1Alw9yuDPKIjzjAgVb7AxuHLpXCMLV9tJzsVpT-qI39fBLY-LXYhoeI9Vuy4EAtYSnL9HVYb7zffb95gYfLBSHrUA9PcwX2BSJjs-lbSdv30vhzPAeiNOYVw8V6JkUq2F_p7lrPsOMueHz_iZLrbT3STVF8CfZYJcyW0__IZ2xAsbtAGcv8ZlDeH6yBvV3X-_RzkzwOLjIwVVdXF9gNTQfD--ea6ecHk2eJRGgPpG2m5Od9wvpFAbFWFPvWnQNKXSYCAONJoVtWhuC0gWVF0weBw1JmDbYzLvKjLUBqW-emnerTPJ80SLMjjJiDG_4NyTvegBwwCCbzD7kc7dIYhaXnJZf8sRuRYV2eh7YGi8hKD5W3zl4ala4dSAFPvqN-IQtVNCJAV-umVDal4NSLxjMTpSRW3rQjiIrYmwETTwhQ_Qj8j1Ib17GIfc2DaCBKk8mL-UvhMcV-Agfuq9KfSjmTntI3x-XbcSad8Bo0RihNVd2UpiHxVZfcU3BbtI1LugFP021SHumpaqXjXHALoeqpbYzd2TtaQlqH2hCD77xuxTaV_qH6iYQ7j28r0awm-r9fuo64qYHhkTrD4XaUa4Jd-okE_Jxj630FhanJB_dON-LCEZaJsi8SP3RngiZDW-ejEayZnUozcGcwajhNt8chPQO_Im4OTIfJnHVAcMMmCZCoFTtMnVquCQPABMrvJse2foYPws9pn6k5NAlAyPQw-7ytjGOJgTIRZQsB2xtPkaO1PxeY1oBVv7b6Ab-JC_JMdKHpUuO3NIo4LmR4kbMFJBImY72E4kEtPzT7opzSJne0lByq5Fl1wKmxrhVrV1kpAZ6UUFrw-O2ZbhbsKFNnSRWCCVn257M-ziwKr5N5fjnDgKoMLgNnLAeo9-C9OXnl9AOOA_hGJC0eihLCxabIBmXpxGkIVDAfsyP7RfL7hvifzQFAhebXubd917Om7RF2hydKSlqBSY7ivJRIpecroe609N0YTuMpvWPu63iJpciEJyebS_wqCnVGLYmOQKyTp8o356INf_viaMceHy09GKGPcmD_cxV8pqzqy9Yduar-ZR1cZHsvB5890IFBVWaG73629wHFevaObPNP041BptpW1GizQb7pmT0ZbAfrZVYuDk0oMRI1bvJTqnux_Oro3ixM8Xf5p8DNaO6_0TaJ7tjw11GNkwyRdSYUdSUH-2LxHmvJyeiBW8iyeR9CERSAHwHc9YvDRTLCt9ewsSx46yIEKeAdRbHXFJE_WTFQPFUrr5XzagWCeUBVkK9Sc8aVTlz5dCWaOmmCAMomKFoDTwRA0w-9L5kEBAm5mpVowT3Bsba-Bg0CPfe5iIphnWyHzE-ZuSSwBwDXm_uZjiTARm1Fym5mhgJ3pu8y9CH_SCsYaJMLjkF2VYhp4iH83XJy5d7wXX-H8U3v-lOKtpb7CD_zZICh31E9XdeCbyPp0QMFwyg74Y3KJFdWXt0-Taybb5FA9t8P1WKaIaUH7qeZhAeUD6n4Z1NGuZnDK2X5rbGQgnbXFcqBnyZK9VI3cunp_yinmMjD2l0opHKSUvfpVyLtWh1m4Y3V2U_7tlP_HFOKZo_KdQEHTnUAX3IYeEUUFd0u77NOjvcYHtbRfyjC-QpZxUtbHHWG9Fx9YBEhIv--6F7smzb-42Rx3u7ODe3Jy7GhtJukZF_MV6gp15C0fxnqOvgDmZTTehPZop-DqO8h00HxLo0fiD5yFk_krajrwNg1BcuCY8kOiKZVmHEz4kdhtz7PDmRA-VQC9patrhRRUbbZSemY8xcdhHF_XfWi-FtOrnPj7h3xGa9qXsKn_IpZH8JBdK0ySas530A3lyWFqgebwoy43_0y5e3Lu0GT5GBNxNx-5kL075qfQ4SviLUQG8217ppp8P-4-LKzBkOCAufVxni_c8dAE1aUALw9CH8PjOQTnoRlJIXEGm-aPB-6PPIWlgFb8m2X9m6IqjuI-OWkkms7SV0ko-o9HVSyoIvxmXR6zdDIgWBbJdo0T-WEcOFKzIMGuaJO5BUWabOvxBzPXiqDRpu4RpGGOEGtcoAo_-0wlIpi6faIsqxkITsRo60KLnUcANw5gv7EnczUlJfk2jtzwRRSsN_XQzlzMIvnzoTzeNjuSbFg7eZYwztzwLwvk_zohzRTVzrLk_jlOWOWn4x1Bg0Du1toMQ-vZSe7RNKudn_7o2x4i50AQkTcWFX6U0SV3dp9nv-9alamFVpzK4oXk-7lvlFfi74pd9MpC7Ru_Bf3eplSGl9rsINULufrRqEE5g_Z51rBa7nGCW3F4jIjY9VqhoeJ2bDORDmM0YC5hJFwDB3hvqejSDGpO2ndWS4KrLU0rcenrgcIMSwb1WNKa9PC1hsKwb2AZCdKYX1jU9lb4zZQXeVxEu37lcniPfgZxk3XJUOo7OKZXuEzr8EEyj0GQ4n8Ld0S5MjuFTHTC8CHD3w88NL3_NhaAzGZlqM4-7VasT5EdlrE9x9bMc7-2Ljz0VlijYvWHo9-EE_a2sblWzeuP0n7NV8mYVM_zmaoT-FqdLO7UPcv2p96TCSw8lc7Wqwm7egvV1Amp-efuCWtOtM4p60uwCLfsXnQIutXUe-3UGTjgeeDiekUbZeT87CSt0JIw8OHNvE5fy2Qao6w8abFVZqS17NqDmmE7N9lmO3wEgXkhGbYr9QpnX8Np6jDyIWkzNlEEuWawx_0gRtQ-wMJEwzfl7r_xe2U-n_gKyM-G3pNng5tYEjMBAaktlroXog9qvPUjxQ9JJ0X9IegjCbgkgyZuasdptHzNzs4j60ndMBDqf8cjTnKCgSaeGJZK1CGAUTqclWjq-aSAqz45Yest-X2ELexKsbgQJt8cRZR_OB4Iywmz065HngQmt1H-2UCARJZgAf7MOlw11zeKXGMPLpG-jnGRALY5w9FvWCOlA0xXfjcoBZfeWSzsUdqHXS9b8-If-t7uNOuojzqpyKuKqBD5ZfLeMhgLmfKhnCcaie9pc1MhCLLkmskQiNA6_GgIejKqsWqePzdM-5WM7DnrMtoZawz96hTMbNxgkT8iUnD_jycSqJD_QiSOBGspY5I0AMcSJwTUfivuGQ2E18tJS_COzDSQ_TFqW_YjjrzUL0PEq3earH7SF_c6LkO0tfzIZ5UjJswrT4gwjYj9Wm92cjavWwWXHO7tMNLUiYyQOcii9fwzgXWWMERDLf52IbNZu1a4s8aoPAhVFUregX7naRxgDryW8ip9O4I_srWEcrYhSzpOJE-FHHmUKOu0YcfQkxea2GaR82bkLVAh9jpAsVt2ojU1WJQdWuoTYmkscDyTzGAE2Ao8_kYuU_ziG8-lkx-4eCFytilVIzq9x9a6c3Zic9TrMIMOnVQ9eIYRvmutpZPD8qJybBVEfbE9rtZW-xJjJwcKo_1T1er7kXyjT_pc12N79g_JMgG3WLwsxGm3Y1eMSxlvTjVjumL433YHsyl7eCJNzUfs4bRZdEITDvQ69PxQNwk_Oksq9dtsM_bam6oqrJVmO0MOQCiCrh26C_2PX_3gPwYvOnAKwNr-CPxGz-rLm8fRt3E68xlyLZdsVy0)
---------------------------------
Conteúdo do arquivo: ./mundo/src/Components/Player.ts
import * as THREE from 'three';
import Experience from '../Experience/Experience'; // Para acesso a recursos, tempo, etc.

// Constantes do jogador e mundo (devem vir de Config)
const WORLD_RADIUS = 50000;
const PLAYER_RADIUS = 0.3;
const PLAYER_CYLINDER_HEIGHT = 1.2; // Altura do corpo
const PLAYER_TOTAL_HEIGHT = PLAYER_CYLINDER_HEIGHT + 2 * PLAYER_RADIUS; // Altura total da cápsula
const PLAYER_HEIGHT_OFFSET = PLAYER_TOTAL_HEIGHT / 2; // Centro da cápsula acima da superfície

export default class Player {
    private experience: Experience;
    public mesh: THREE.Mesh; // Malha visível do jogador
    public isLocalPlayer: boolean;
    private currentSurfaceNormal: THREE.Vector3; // Normal da superfície onde o jogador está

    // Vetores auxiliares para cálculos
    private cameraDirection = new THREE.Vector3();
    private playerUp = new THREE.Vector3();
    private lookAtPoint = new THREE.Vector3();
    private tempQuaternion = new THREE.Quaternion();
    private worldQuaternion = new THREE.Quaternion();

    constructor(experience: Experience, initialSurfaceNormal: THREE.Vector3, isLocal: boolean) {
        this.experience = experience;
        this.isLocalPlayer = isLocal;
        this.currentSurfaceNormal = initialSurfaceNormal.clone().normalize();

        this.mesh = this.createPlayerMesh();
        this.placeOnSurface(this.currentSurfaceNormal); // Posiciona inicialmente

        console.log(`Player ${isLocal ? 'Local' : 'Remote'} created.`);
    }

    private createPlayerMesh(): THREE.Mesh {
        // Usar CapsuleGeometry para representar o jogador
        const playerGeometry = new THREE.CapsuleGeometry(
            PLAYER_RADIUS,
            PLAYER_CYLINDER_HEIGHT,
            4, // capSegments
            8  // radialSegments
        );
        // Cor diferente para jogador local/remoto?
        const playerMaterial = new THREE.MeshStandardMaterial({
             color: this.isLocalPlayer ? 0xffa500 : 0xcccccc, // Laranja para local, cinza para remoto
             // wireframe: true // Para debug
             });
        const playerAvatar = new THREE.Mesh(playerGeometry, playerMaterial);
        playerAvatar.name = this.isLocalPlayer ? "LocalPlayer" : "RemotePlayer";
        playerAvatar.castShadow = true; // Jogador projeta sombra
        return playerAvatar;
    }

    // Posiciona e orienta o jogador na superfície da esfera
    private placeOnSurface(surfaceNormal: THREE.Vector3): void {
        const surfacePoint = surfaceNormal.clone().multiplyScalar(WORLD_RADIUS);
        const finalPosition = surfacePoint.add(surfaceNormal.clone().multiplyScalar(PLAYER_HEIGHT_OFFSET));
        this.mesh.position.copy(finalPosition);

        // Orientar o 'up' do jogador para fora da esfera (normal da superfície)
        this.mesh.up.copy(surfaceNormal);
         this.playerUp.copy(surfaceNormal); // Guarda a normal atual

        // Tenta alinhar o eixo Y local da cápsula com a normal da superfície
        this.mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), surfaceNormal);

        // Guarda a normal atual
        this.currentSurfaceNormal.copy(surfaceNormal);
    }


    // Atualiza o jogador local com base na câmera (chamado pelo World)
    update(delta: number, camera: THREE.PerspectiveCamera): void {
        if (!this.isLocalPlayer) return; // Só atualiza o jogador local aqui

        // 1. Atualizar Posição: Colocar o avatar na superfície logo abaixo da câmera
        const cameraPosition = camera.position;
        const surfaceNormal = cameraPosition.clone().normalize();
        this.placeOnSurface(surfaceNormal); // Reposiciona e reorienta (up)

        // 2. Atualizar Rotação (Olhar): Fazer o avatar olhar na direção horizontal da câmera
        // Pega a direção que a câmera está olhando no espaço mundial
        camera.getWorldDirection(this.cameraDirection);

        // Queremos a projeção dessa direção no plano tangencial à esfera no ponto do jogador.
        // O plano tangencial tem a normal `playerUp` (que é a `surfaceNormal`).
        // Projetar cameraDirection no plano: directionPlanar = direction - (direction dot up) * up
        const projectionOntoUp = this.cameraDirection.dot(this.playerUp);
        const lookDirectionPlanar = this.cameraDirection.clone().sub(
            this.playerUp.clone().multiplyScalar(projectionOntoUp)
        );
        lookDirectionPlanar.normalize(); // Normaliza a direção no plano

        // Se a direção planar for quase zero (câmera olhando diretamente para cima/baixo),
        // evitamos lookAt nesse vetor para não causar problemas. Podemos manter a rotação anterior
        // ou usar a direção 'forward' da câmera projetada.
        if (lookDirectionPlanar.lengthSq() > 0.001) {
             // Calcula o ponto para onde olhar
            this.lookAtPoint.copy(this.mesh.position).add(lookDirectionPlanar);
             this.mesh.lookAt(this.lookAtPoint);
        } else {
            // Caso de olhar pra cima/baixo: Pega a direção "frente" da camera (eixo Z local dela)
            // e projeta no plano tangencial
            camera.getWorldQuaternion(this.worldQuaternion);
            const cameraForward = new THREE.Vector3(0, 0, -1).applyQuaternion(this.worldQuaternion);
            const forwardProjectionOntoUp = cameraForward.dot(this.playerUp);
            const forwardPlanar = cameraForward.sub(this.playerUp.clone().multiplyScalar(forwardProjectionOntoUp));
            forwardPlanar.normalize();
            if(forwardPlanar.lengthSq() > 0.001) {
              this.lookAtPoint.copy(this.mesh.position).add(forwardPlanar);
              this.mesh.lookAt(this.lookAtPoint);
            }
            // Se ainda assim falhar, mantém a rotação anterior (não faz nada)
        }

        // console.log("Player updated based on camera");
    }

    // TODO: Método para atualizar jogadores remotos com dados do servidor
    // updateRemote(state: { position: any, quaternion: any }) { ... }

    dispose(scene: THREE.Scene): void {
      scene.remove(this.mesh);
      this.mesh.geometry.dispose();
      (this.mesh.material as THREE.Material).dispose();
      console.log(`Player ${this.isLocalPlayer ? 'Local' : 'Remote'} disposed`);
    }
}---------------------------------
Conteúdo do arquivo: ./mundo/src/Managers/InputManager.ts
import EventEmitter from '../Utils/EventEmitter';
import nipplejs, { JoystickManager } from 'nipplejs';

export default class InputManager extends EventEmitter {
    // Estado das teclas de movimento
    public moveState: { [key: string]: boolean } = {
        forward: false,
        backward: false,
        left: false,
        right: false,
        // Adicionar outros estados de ação aqui (jump, interact, etc.)
    };

    // Mapeamento de teclas para ações (pode ser configurável)
    private keyMap: { [key: string]: string } = {
        KeyW: 'forward', ArrowUp: 'forward',
        KeyS: 'backward', ArrowDown: 'backward',
        KeyA: 'left', ArrowLeft: 'left',
        KeyD: 'right', ArrowRight: 'right',
        // Space: 'jump',
        // KeyE: 'interact',
    };

    private joystickManager: JoystickManager | null = null;
    private isTouchDevice: boolean = false;

    constructor() {
        super();
        this.isTouchDevice = this.detectTouchDevice();

        if (this.isTouchDevice) {
            this.setupJoystick();
            // Ocultar instruções de PointerLock se for touch
            const instructions = document.getElementById('instructions');
            if (instructions) {
                instructions.style.display = 'none';
            }
        } else {
            this.setupKeyboardListeners();
        }
        // Adicionar listeners para mouse, gamepad, sensores aqui
    }

    private detectTouchDevice(): boolean {
        return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    }

    private setupKeyboardListeners(): void {
        document.addEventListener('keydown', this.handleKeyDown);
        document.addEventListener('keyup', this.handleKeyUp);
    }

    private setupJoystick(): void {
        const joystickContainer = document.getElementById('joystick-container');
        if (!joystickContainer) {
            console.error('Joystick container not found!');
            return;
        }
        joystickContainer.style.display = 'block'; // Torna o contêiner visível

        const options: nipplejs.JoystickManagerOptions = {
            zone: joystickContainer,
            mode: 'static', // 'dynamic', 'semi', 'static'
            position: { left: '50%', top: '50%' }, // Centralizado dentro do container
            color: 'white',
            size: 150, // Tamanho do joystick
            threshold: 0.1, // Sensibilidade
            fadeTime: 250,
            multitouch: false,
            // dataOnly: false, // Se true, não desenha o joystick
            // restJoystick: true, // Se true, o joystick volta para a posição inicial
            // restOpacity: 0.5,
        };

        this.joystickManager = nipplejs.create(options);

        this.joystickManager.on('start', () => {
            // console.log('Joystick start');
            // Não precisamos fazer nada específico no start, o 'move' cuidará do estado
        });

        this.joystickManager.on('move', (evt, data) => {
            if (!data.direction) {
                this.resetMoveStateFromJoystick();
                return;
            }
            const angle = data.angle.degree;
            let newMoveState = { ...this.moveState }; // Copia para evitar mutação direta e trigger desnecessário

            // Resetar estados antes de definir novos
            newMoveState.forward = false;
            newMoveState.backward = false;
            newMoveState.left = false;
            newMoveState.right = false;

            // Definir estados com base no ângulo do joystick
            // Ajuste os ranges de ângulo conforme necessário para a sensação desejada
            if (angle > 45 && angle < 135) { // Cima
                newMoveState.forward = true;
            } else if (angle > 225 && angle < 315) { // Baixo
                newMoveState.backward = true;
            }

            if (angle > 135 && angle < 225) { // Esquerda
                newMoveState.left = true;
            } else if ((angle > 315 || angle < 45) && angle !== 0) { // Direita (angle !== 0 para evitar conflito com 'end')
                newMoveState.right = true;
            }
            
            // Verifica se houve mudança real no estado para disparar o evento
            if (JSON.stringify(this.moveState) !== JSON.stringify(newMoveState)) {
                this.moveState = newMoveState;
                this.trigger('moveStateChanged', this.moveState);
                // console.log('Joystick move:', this.moveState);
            }
        });

        this.joystickManager.on('end', () => {
            // console.log('Joystick end');
            this.resetMoveStateFromJoystick();
            this.trigger('moveStateChanged', this.moveState);
        });
    }

    private resetMoveStateFromJoystick(): void {
        this.moveState.forward = false;
        this.moveState.backward = false;
        this.moveState.left = false;
        this.moveState.right = false;
    }


    // Usar arrow functions para manter o 'this' correto nos listeners
    private handleKeyDown = (event: KeyboardEvent): void => {
        const action = this.keyMap[event.code];
        if (action && !this.moveState[action]) { // Processa apenas se a ação existir e não estiver ativa
            this.moveState[action] = true;
            this.trigger('action:' + action + ':start', event); // Emite evento de início da ação
            this.trigger('moveStateChanged', this.moveState); // Emite estado geral
            // console.log(`Action Start: ${action}`);
        }
        // Permitir outras teclas (ex: F5, F12) passarem
        // event.preventDefault(); // Descomentar se quiser impedir ações padrão do navegador para teclas mapeadas
    };

    private handleKeyUp = (event: KeyboardEvent): void => {
        const action = this.keyMap[event.code];
        if (action && this.moveState[action]) { // Processa apenas se a ação existir e estiver ativa
            this.moveState[action] = false;
            this.trigger('action:' + action + ':stop', event); // Emite evento de fim da ação
            this.trigger('moveStateChanged', this.moveState); // Emite estado geral
            // console.log(`Action Stop: ${action}`);
        }
    };

    dispose(): void {
        // Remover listeners
        if (!this.isTouchDevice) {
            document.removeEventListener('keydown', this.handleKeyDown);
            document.removeEventListener('keyup', this.handleKeyUp);
        }

        if (this.joystickManager) {
            this.joystickManager.destroy();
            const joystickContainer = document.getElementById('joystick-container');
            if (joystickContainer) {
                joystickContainer.style.display = 'none';
            }
        }
        super.dispose(); // Limpa callbacks do EventEmitter
        console.log('InputManager disposed');
    }
}
---------------------------------
Conteúdo do arquivo: ./mundo/src/vite-env.d.ts
/// <reference types="vite/client" />
---------------------------------
Conteúdo do arquivo: ./mundo/src/Config/Config.ts
// src/Config/Config.ts
import * as THREE from 'three'; // Import THREE para tipos se necessário

export default class Config {
    // --- Debugging ---
    public readonly debug = {
        logExperienceAccess: true, // Habilita o console.log em main.ts
        // Adicione outras flags de debug aqui (ex: stats.js, helpers)
        // showWorldAxes: false,
        // showLightHelpers: false,
    };

    // --- World Settings ---
    public readonly world = {
        radius: 50000,
        environment: {
            ambientLightIntensity: 0.6,
            sunLightIntensity: 1.2,
            // Posição inicial do sol (pode ser mais complexa depois)
            sunPosition: new THREE.Vector3(1, 1.5, 0.5).normalize().multiplyScalar(50000 * 1.5), // Exemplo baseado no código anterior
        },
        markers: {
            height: 10,
            colors: {
                'X+': 0xff0000,
                'X-': 0x0000ff,
                'Z+': 0xffff00,
                'Z-': 0x00ff00,
                'Y+': 0xffffff,
                'Y-': 0x808080,
            }
        }
    };

    // --- Player Settings ---
    public readonly player = {
        radius: 0.3,
        cylinderHeight: 1.2,
        // Usamos getters para valores derivados, garantindo consistência
        get totalHeight(): number {
            return this.cylinderHeight + 2 * this.radius;
        },
        get heightOffset(): number {
            return this.totalHeight / 2;
        },
        colors: {
            local: 0xffa500, // Laranja
            remote: 0xcccccc, // Cinza
        }
    };

    // --- Camera Settings ---
    public readonly camera = {
        fov: 75,
        near: 0.1,
        // Far plane precisa do raio do mundo, usamos um getter
        get far(): number {
            // Acessamos o raio do mundo do próprio config
            // Isso funciona bem se Config for um Singleton ou se a instância for consistente
            return Config.instance.world.radius * 2.5;
        },
        heightAboveSurface: 1.7,
        moveSpeed: 30.0,
    };

    // --- Renderer Settings ---
    public readonly renderer = {
        antialias: true,
        pixelRatio: {
            max: 2 // Limita o pixel ratio para performance
        },
        // Configurações futuras (descomente e ajuste quando implementar)
        // shadowMap: {
        //     enabled: true,
        //     type: THREE.PCFSoftShadowMap, // Ex: THREE.BasicShadowMap, THREE.PCFShadowMap, THREE.PCFSoftShadowMap, THREE.VSMShadowMap
        // },
        // outputColorSpace: THREE.SRGBColorSpace, // ou LinearSRGBColorSpace
        // toneMapping: THREE.ACESFilmicToneMapping, // Ex: NoToneMapping, LinearToneMapping, ReinhardToneMapping, CineonToneMapping, ACESFilmicToneMapping
        // toneMappingExposure: 1.0,
    };

    // --- Input Settings ---
    public readonly input = {
        keyMap: {
            // Movimento
            KeyW: 'forward', ArrowUp: 'forward',
            KeyS: 'backward', ArrowDown: 'backward',
            KeyA: 'left', ArrowLeft: 'left',
            KeyD: 'right', ArrowRight: 'right',
            // Ações futuras
            // Space: 'jump',
            // KeyE: 'interact',
        }
        // Adicionar configurações de sensibilidade do mouse, gamepad, etc. aqui
    };

    // --- Network Settings (Placeholder) ---
    public readonly network = {
        // serverUrl: 'ws://localhost:8080',
        // updateRate: 15, // Hz
    };

    // --- Singleton Pattern ---
    // Facilita o acesso global à configuração, especialmente para getters que dependem de outros valores
    private static _instance: Config | null = null;

    constructor() {
        if (Config._instance) {
            // Você pode lançar um erro, retornar a instância existente, ou apenas avisar.
            // console.warn("Config class is intended as a Singleton. Returning existing instance.");
            return Config._instance;
        }
        Config._instance = this;
    }

    // Getter estático para acessar a instância única
    public static get instance(): Config {
        if (!Config._instance) {
            new Config(); // Cria a instância se ela ainda não existe
        }
        return Config._instance!; // O '!' assume que a instância sempre existirá após a chamada
    }
}

// Opcional: Exportar uma instância diretamente se preferir não usar o Singleton estático
// export const config = new Config();---------------------------------
Conteúdo do arquivo: ./mundo/src/main.ts
import Experience from './Experience/Experience';
import './style.css'; // Importa o CSS

// Pega o elemento canvas do DOM
const canvasElement = document.querySelector('#webgl') as HTMLCanvasElement | null;

if (!canvasElement) {
    console.error("Canvas element #webgl not found!");
} else {
    // Cria a instância da Experiência, passando o canvas
    const experience = new Experience(canvasElement);

    // O loop de animação é iniciado dentro do Time/Experience
    // Não precisamos mais da função animate() aqui.

     // Para debug no console
    (window as any).experience = experience;
    console.log("Application started. Access 'experience' in console for debugging.");

    // Lógica de Hot Module Replacement (HMR) para desenvolvimento com Vite (opcional)
    if (import.meta.hot) {
        import.meta.hot.dispose(() => {
            console.log('Disposing old Experience due to HMR');
            experience.dispose();
        });
         import.meta.hot.accept(() => {
            console.log('HMR update detected');
             // A recarga da página geralmente é suficiente aqui,
             // mas poderia tentar recriar a Experience se necessário.
             window.location.reload(); // Força recarga para garantir estado limpo
        });
    }
}
---------------------------------
Conteúdo do arquivo: ./mundo/src/Experience/Experience.ts
import * as THREE from 'three';
import Sizes from '../Utils/Sizes';
import Time from '../Utils/Time';
import Camera from '../Camera';
import Renderer from '../Renderer';
import World from '../World/World';
import InputManager from '../Managers/InputManager';
import Config from '../Config/Config'; // Importando a classe Config

export default class Experience {
    // **Propriedade estática para o padrão Singleton**
    static instance: Experience | null = null;

    // **Propriedades públicas da classe**
    public canvas: HTMLCanvasElement;
    public sizes: Sizes;
    public time: Time;
    public scene: THREE.Scene;
    public camera: Camera;
    public renderer: Renderer;
    public world: World;
    public inputManager: InputManager;
    public config: Config;

    // **Construtor**
    constructor(canvas: HTMLCanvasElement) {
        // Implementação do padrão Singleton
        if (Experience.instance) {
            return Experience.instance;
        }
        Experience.instance = this;

        // Validação do canvas
        if (!canvas) {
            throw new Error("Canvas element not provided to Experience");
        }
        this.canvas = canvas;

        // **Inicialização dos componentes**
        // Ordem é importante: Sizes e Time devem vir primeiro
        this.sizes = new Sizes();
        this.time = new Time();

        // Criando a instância de Config
        this.config = new Config();

        // Configuração inicial da cena
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x87CEEB); // Fundo azul céu

        // **Instanciação dos módulos principais**
        // Passamos a instância de Experience e, quando necessário, Config
        this.camera = new Camera(this, this.config);
        this.renderer = new Renderer(this, this.config);
        this.world = new World(this, this.config);
        this.inputManager = new InputManager(); // Passando Config explicitamente

        // **Configuração de eventos**
        this.sizes.on('resize', () => {
            this.resize();
        });
        this.time.on('tick', () => {
            this.update();
        });

        console.log('Experience Initialized');
    }

    // **Método de atualização chamado a cada tick**
    private update(): void {
        // Atualiza o InputManager e passa o estado de movimento para a câmera
        this.camera.update(this.time.delta, this.inputManager.moveState);

        // Atualiza o mundo
        this.world.update(this.time.delta);

        // Renderiza a cena
        this.renderer.update();
    }

    // **Método de redimensionamento**
    private resize(): void {
        // Camera e Renderer já escutam o evento 'resize' do Sizes internamente
        // Não é necessário adicionar lógica adicional aqui
    }

    // **Método de limpeza**
    dispose(): void {
        // Remove os listeners de eventos
        this.time.off('tick', () => {
            this.update();
        });
        this.sizes.off('resize', () => {
            this.resize();
        });

        // Chama o dispose dos módulos na ordem inversa de criação
        this.inputManager.dispose();
        this.world.dispose();
        this.renderer.dispose();
        this.camera.dispose();

        // A limpeza dos filhos da cena pode ser delegada ao World, se necessário
        // if (this.scene) {
        //     // A limpeza dos filhos da cena pode ser delegada ao World, se necessário
        // }

        this.time.dispose();
        this.sizes.dispose();

        // Reseta a instância Singleton
        Experience.instance = null;
        console.log('Experience Disposed');
    }
}
---------------------------------
Conteúdo do arquivo: ./mundo/src/World/World.ts
import * as THREE from 'three';
import Experience from '../Experience/Experience';
import Environment from './Environment'; // Importaremos, mas podemos implementar depois
import Player from '../Components/Player';
import Time from '../Utils/Time';
import Camera from '../Camera'; // Precisamos da referência da câmera para o jogador
import Config from '../Config/Config';

// Constantes do mundo (podem ir para Config)

export default class World {
    private experience: Experience;
    private scene: THREE.Scene;
    private time: Time;
    private camera: Camera;
    private config: Config;

    environment?: Environment; // Ambiente (luzes, skybox) - Opcional inicialmente
    player?: Player; // Jogador local
    // Outros players remotos e objetos interativos virão depois
    // remotePlayers: Map<string, Player> = new Map();
    // interactiveObjects: Map<string, InteractiveObject> = new Map();

    private worldSphere: THREE.Mesh; // A esfera do mundo

    constructor(experience: Experience, config: Config) {
        this.experience = experience;
        this.scene = this.experience.scene;
        this.time = this.experience.time;
        this.camera = this.experience.camera;
        this.config = config;
        // 1. Criar o Mundo (Esfera)
        this.worldSphere = this.createWorldSphere();
        this.scene.add(this.worldSphere);

        // 2. Criar o Ambiente (Luzes)
        this.environment = new Environment(this.experience, this.config);

        // 3. Criar Marcadores (opcional, mas bom para referência)
        this.createMarkers();

        // 4. Criar o Jogador Local
        // Passamos a posição inicial da câmera como referência para onde o jogador deve começar
        this.player = new Player(this.experience, this.camera.initialSurfacePos, true); // true = isLocalPlayer
        this.scene.add(this.player.mesh); // Adiciona a malha do jogador à cena

        console.log('World and initial elements created.');
    }

    private createWorldSphere(): THREE.Mesh {
        const worldGeometry = new THREE.SphereGeometry(this.config.world.radius, 64, 32);
        const worldMaterial = new THREE.MeshStandardMaterial({
            color: 0x228B22, // Verde floresta
             side: THREE.FrontSide, // Renderiza o lado externo (padrão)
            // flatShading: true, // Para um visual low-poly
        });
        const sphere = new THREE.Mesh(worldGeometry, worldMaterial);
        sphere.name = "WorldSphere";
        sphere.receiveShadow = true; // Mundo recebe sombra
        console.log('Mundo Básico (Issue #3) - Esfera criada.');
        return sphere;
    }

    // Função auxiliar para posicionar na superfície da esfera
    // Poderia ser movida para um Utils/Geometry.ts se usada em mais lugares
    private placeOnSphereSurface(
        object: THREE.Object3D,
        surfaceNormal: THREE.Vector3, // Normal normalizada da superfície onde colocar
        heightOffset: number = 0
    ): void {
        const surfacePoint = surfaceNormal.clone().multiplyScalar(this.config.world.radius);
        const finalPosition = surfacePoint.clone().add(surfaceNormal.clone().multiplyScalar(heightOffset));
        object.position.copy(finalPosition);

        // Orientar o objeto: 'up' aponta para fora da esfera (é a normal)
        object.up.copy(surfaceNormal);

        // Fazer o objeto olhar para o centro da esfera (mais simples para orientação inicial)
        // Ajustes finos de rotação podem ser feitos depois se necessário
        object.lookAt(0, 0, 0);

        // Para cápsulas ou objetos que precisam ficar "em pé":
        // Se lookAt(0,0,0) deixar o objeto deitado (eixo Y local apontando para o centro),
        // precisamos rotacionar 90 graus em torno do eixo X LOCAL.
        // Isso depende da orientação padrão do modelo/geometria.
        // Ex: Para THREE.CapsuleGeometry padrão, o eixo longo é Y.
        // Se up é (0,1,0) e lookAt é (0,0,0), ela fica em pé.
        // Se up é (1,0,0) e lookAt é (0,0,0), ela fica deitada no eixo X.
        // Precisamos alinhar o Y local com o 'up' (normal da superfície).
        // object.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), surfaceNormal); // Alternativa para orientação
    }


    private createMarkers(): void {
        const markerHeight = 10;
        const markerHeightOffset = markerHeight / 2;
        const markerGeometry = new THREE.BoxGeometry(markerHeight, markerHeight, markerHeight);

        const createMarker = (color: number, surfaceNormal: THREE.Vector3, name: string) => {
            const material = new THREE.MeshStandardMaterial({ color });
            const marker = new THREE.Mesh(markerGeometry, material);
            marker.name = name;
            marker.castShadow = true;
            this.placeOnSphereSurface(marker, surfaceNormal, markerHeightOffset);
            this.scene.add(marker);
            console.log(`Marker ${name} adicionado.`);
        };

        createMarker(0xff0000, new THREE.Vector3(1, 0, 0).normalize(), 'MarkerX+');
        createMarker(0x0000ff, new THREE.Vector3(-1, 0, 0).normalize(), 'MarkerX-');
        createMarker(0xffff00, new THREE.Vector3(0, 0, 1).normalize(), 'MarkerZ+');
         createMarker(0x00ff00, new THREE.Vector3(0, 0, -1).normalize(), 'MarkerZ-'); // Marcador extra
         createMarker(0xffffff, new THREE.Vector3(0, 1, 0).normalize(), 'MarkerY+'); // Polo Norte
         createMarker(0x808080, new THREE.Vector3(0, -1, 0).normalize(), 'MarkerY-'); // Polo Sul
    }

    update(delta: number): void {
        // Atualizar jogador local (passando a posição/orientação da câmera)
        if (this.player && this.camera.controls.isLocked) {
            this.player.update(delta, this.camera.instance);
        }

        // Atualizar outros elementos do mundo (jogadores remotos, objetos interativos, ambiente)
        // if (this.environment) this.environment.update(delta);
        // this.remotePlayers.forEach(player => player.update(delta));
        // this.interactiveObjects.forEach(obj => obj.update(delta));
    }

     dispose(): void {
      // Remover objetos da cena, dispose de geometrias/materiais se necessário
      if (this.worldSphere) {
        this.scene.remove(this.worldSphere);
        this.worldSphere.geometry.dispose();
        (this.worldSphere.material as THREE.Material).dispose();
      }
       if (this.environment) this.environment.dispose();
       if (this.player) this.player.dispose(this.scene);
       // Remover marcadores...
      console.log('World disposed');
    }
}---------------------------------
Conteúdo do arquivo: ./mundo/src/World/Environment.ts
import * as THREE from 'three';
import Experience from '../Experience/Experience';
import Config from '../Config/Config';

export default class Environment {
    private experience: Experience;
    private scene: THREE.Scene;
    private sunLight: THREE.DirectionalLight;
    private ambientLight: THREE.AmbientLight;
    private config: Config;
    // private lightHelper?: THREE.DirectionalLightHelper; // Opcional para debug

    constructor(experience: Experience, config: Config) {
        this.experience = experience;
        this.scene = this.experience.scene;
        this.config = config;

        this.ambientLight = this.createAmbientLight();
        this.sunLight = this.createSunLight();

        this.scene.add(this.ambientLight);
        this.scene.add(this.sunLight);
        // this.scene.add(this.sunLight.target); // Alvo padrão é (0,0,0)

         // Helper para visualizar a luz
        // this.lightHelper = new THREE.DirectionalLightHelper(this.sunLight, 50);
        // this.scene.add(this.lightHelper);

        console.log('Environment (Lights) created.');
        // Carregar mapa de ambiente (HDRI) pode ser feito aqui futuramente
    }

    private createAmbientLight(): THREE.AmbientLight {
        const light = new THREE.AmbientLight(
            0xffffff,
            this.config.world.environment.ambientLightIntensity
        );
        light.name = "AmbientLight";
        return light;
    }

    private createSunLight(): THREE.DirectionalLight {
        const light = new THREE.DirectionalLight(
            0xffffff,
            this.config.world.environment.sunLightIntensity // Usar config
        );
        light.name = "SunLight";
        // Usar posição do config
        light.position.copy(this.config.world.environment.sunPosition);
        light.target.position.set(0, 0, 0);
          
        // Configurações de sombra (ativar se necessário)
        // light.castShadow = true;
        // light.shadow.mapSize.width = 2048;
        // light.shadow.mapSize.height = 2048;
        // light.shadow.camera.near = 0.5;
        // light.shadow.camera.far = WORLD_RADIUS * 3;
        // // Ajustar a área da sombra (frustum) para cobrir a área visível
        // const shadowCamSize = WORLD_RADIUS * 0.1; // Ajustar conforme necessário
        // light.shadow.camera.left = -shadowCamSize;
        // light.shadow.camera.right = shadowCamSize;
        // light.shadow.camera.top = shadowCamSize;
        // light.shadow.camera.bottom = -shadowCamSize;
        // light.shadow.bias = -0.001; // Ajustar para evitar shadow acne


        return light;
    }

    update(delta: number): void {
        // Animar a luz do sol, se desejado
        // Ex: Simular ciclo dia/noite
        // const angle = this.experience.time.elapsed * 0.00005; // Velocidade da rotação
        // this.sunLight.position.set(
        //     Math.cos(angle) * WORLD_RADIUS * 1.5,
        //     WORLD_RADIUS * 1.0, // Manter altura ou variar
        //     Math.sin(angle) * WORLD_RADIUS * 1.5
        // );
        // this.sunLight.lookAt(0, 0, 0);
        // if (this.lightHelper) this.lightHelper.update();
    }

    dispose(): void {
      this.scene.remove(this.ambientLight);
      this.scene.remove(this.sunLight);
      // this.scene.remove(this.sunLight.target);
      this.ambientLight.dispose();
      this.sunLight.dispose();
      // if (this.lightHelper) this.scene.remove(this.lightHelper);
      console.log('Environment disposed');
    }
}---------------------------------
Conteúdo do arquivo: ./mundo/src/Camera.ts
import * as THREE from 'three';
import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls.js';
import Experience from './Experience/Experience';
import Sizes from './Utils/Sizes';
import Config from './Config/Config';

export default class Camera {
    private experience: Experience;
    private sizes: Sizes;
    private scene: THREE.Scene;
    private canvas: HTMLCanvasElement;
    private config: Config;

    instance: THREE.PerspectiveCamera; // Câmera principal
    controls: PointerLockControls; // Controles
    initialSurfacePos: THREE.Vector3; // Posição inicial na superfície (referência)


    constructor(experience: Experience, config: Config) {
        this.experience = experience;
        this.sizes = this.experience.sizes;
        this.scene = this.experience.scene;
        this.canvas = this.experience.canvas;
        this.config = config;

        this.initialSurfacePos = new THREE.Vector3(0, this.config.world.radius, 1).normalize(); // Perto do polo norte

        this.instance = this.createCamera();
        this.controls = this.createControls();

        this.setupResizeListener();
        this.setupPointerLockUI();

        this.scene.add(this.instance); // Adiciona a câmera à cena (necessário para controles)
    }

    private createCamera(): THREE.PerspectiveCamera {
        const camera = new THREE.PerspectiveCamera(
            this.config.camera.fov,
            this.sizes.aspectRatio,
            this.config.camera.near,
            this.config.camera.far 
        );

        // Posição inicial da câmera
        const cameraInitialPosition = this.initialSurfacePos.clone()
                                      .multiplyScalar(this.config.world.radius + this.config.camera.heightAboveSurface);
        camera.position.copy(cameraInitialPosition);

        // Orientar a câmera corretamente (up aponta para fora da esfera)
        camera.up.copy(this.initialSurfacePos); // Normal da superfície no ponto inicial
        camera.lookAt(0, 0, 0); // Olhar para o centro inicialmente (será ajustado pelos controles)

        return camera;
    }

    private createControls(): PointerLockControls {
        const controls = new PointerLockControls(this.instance, this.canvas); // Usar canvas diretamente
        // O 'lock'/'unlock' é tratado pela UI abaixo
        this.scene.add(controls.object); // Adiciona o objeto dos controles à cena
        return controls;
    }

    private setupPointerLockUI(): void {
        const instructions = document.createElement('div');
        instructions.setAttribute('id', 'instructions'); // Dar um ID para fácil remoção/estilo
        // Estilização (pode mover para CSS)
        instructions.style.position = 'absolute';
        instructions.style.top = '50%';
        instructions.style.left = '50%';
        instructions.style.transform = 'translate(-50%, -50%)';
        instructions.style.width = 'auto';
        instructions.style.padding = '10px 20px';
        instructions.style.fontFamily = 'Arial, sans-serif';
        instructions.style.fontSize = '16px';
        instructions.style.textAlign = 'center';
        instructions.style.color = '#ffffff';
        instructions.style.backgroundColor = 'rgba(0,0,0,0.7)';
        instructions.style.border = '1px solid #ffffff';
        instructions.style.borderRadius = '5px';
        instructions.style.cursor = 'pointer';
        instructions.style.zIndex = '10';
        instructions.innerHTML = 'Clique aqui para controlar';
        document.body.appendChild(instructions);

        const lockPointer = () => { this.controls.lock(); };
        instructions.addEventListener('click', lockPointer, false); // Adicionar listener

        this.controls.addEventListener('lock', () => { instructions.style.display = 'none'; });
        this.controls.addEventListener('unlock', () => { instructions.style.display = 'block'; }); // Usar block ou ''
    }


    private setupResizeListener(): void {
        this.sizes.on('resize', () => {
            this.resize();
        });
    }

    resize(): void {
        this.instance.aspect = this.sizes.aspectRatio;
        this.instance.updateProjectionMatrix();
    }

    update(delta: number, moveState: { [key: string]: boolean }): void {
         if (this.controls.isLocked === true) {
            const moveSpeed = 30.0; // Mover para Config?
            const cameraObject = this.controls.object; // Objeto da câmera que os controles movem

            // --- Movimento da Câmera ---
            const direction = new THREE.Vector3();
            direction.z = Number(moveState['forward']) - Number(moveState['backward']);
            direction.x = Number(moveState['right']) - Number(moveState['left']);
            direction.normalize(); // Garante movimento consistente em diagonais
            const moveDistance = moveSpeed * delta;

            // Aplica movimento relativo à direção da câmera
            this.controls.moveForward(direction.z * moveDistance);
            this.controls.moveRight(direction.x * moveDistance);

            // --- Gravidade Simulada / Manter na Superfície ---
            const currentPos = cameraObject.position;
            const surfaceNormal = currentPos.clone().normalize(); // Direção radial (para fora)
            const targetPosition = surfaceNormal.multiplyScalar(this.config.world.radius + this.config.camera.heightAboveSurface);

            // Correção instantânea para manter a altura
            cameraObject.position.copy(targetPosition);

            // --- Orientação da Câmera ---
            // Garante que o 'up' da câmera sempre aponte para fora da esfera
            cameraObject.up.copy(surfaceNormal); // O up da câmera É a normal da superfície
            // PointerLockControls cuida do lookAt baseado no movimento do mouse
        }
    }

    dispose(): void {
      // Remover listeners de controle e UI
      const instructions = document.getElementById('instructions');
      if (instructions) {
        instructions.removeEventListener('click', () => this.controls.lock()); // Precisa da referência exata da função para remover
        document.body.removeChild(instructions);
      }
      this.controls.dispose();
      // Remover listener do sizes? O dispose do sizes já limpa os callbacks.
    }
}---------------------------------
Conteúdo do arquivo: ./mundo/src/Renderer.ts
import * as THREE from 'three';
import Experience from './Experience/Experience'; // Precisaremos da instância Experience
import Sizes from './Utils/Sizes';
import Camera from './Camera'; // Precisaremos da instância da Camera
import Config from './Config/Config';

export default class Renderer {
    private experience: Experience;
    private sizes: Sizes;
    private scene: THREE.Scene;
    private camera: Camera;
    private canvas: HTMLCanvasElement;
    private config: Config;
    instance: THREE.WebGLRenderer; // Instância pública para acesso se necessário

    constructor(experience: Experience, config: Config) {
        this.experience = experience;
        this.sizes = this.experience.sizes;
        this.scene = this.experience.scene;
        this.camera = this.experience.camera;
        this.canvas = this.experience.canvas;
        this.config = config;

        this.instance = this.createRenderer();
        this.setupResizeListener();
    }

    private createRenderer(): THREE.WebGLRenderer {
        const renderer = new THREE.WebGLRenderer({
            canvas: this.canvas,
            antialias: this.config.renderer.antialias,
        });
        renderer.setSize(this.sizes.width, this.sizes.height);
        renderer.setPixelRatio(this.sizes.pixelRatio);
        // Adicionar configurações futuras aqui (ex: shadow map, encoding)
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputColorSpace = THREE.SRGBColorSpace; // Ou THREE.LinearSRGBColorSpace
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;

        return renderer;
    }

    private setupResizeListener(): void {
        this.sizes.on('resize', () => {
            this.resize();
        });
    }

    resize(): void {
        this.instance.setSize(this.sizes.width, this.sizes.height);
        this.instance.setPixelRatio(this.sizes.pixelRatio);
    }

    update(): void {
        // Renderiza a cena com a câmera
        this.instance.render(this.scene, this.camera.instance);
    }

    dispose(): void {
      this.instance.dispose();
      // Remover listener do sizes? O dispose do sizes já limpa os callbacks.
    }
}---------------------------------
Conteúdo do arquivo: ./mundo/src/Utils/Sizes.ts
import EventEmitter from './EventEmitter';

export default class Sizes extends EventEmitter {
    width: number;
    height: number;
    pixelRatio: number;
    aspectRatio: number;

    constructor() {
        super();

        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.pixelRatio = Math.min(window.devicePixelRatio, 2);
        this.aspectRatio = this.width / this.height;

        this.setupResizeListener();
    }

    private setupResizeListener(): void {
        window.addEventListener('resize', () => {
            this.width = window.innerWidth;
            this.height = window.innerHeight;
            this.pixelRatio = Math.min(window.devicePixelRatio, 2);
            this.aspectRatio = this.width / this.height;

            this.trigger('resize'); // Emite o evento 'resize'
        });
    }

    dispose(): void {
      // TODO: Remover event listener de resize se necessário (ou deixar, geralmente não causa problema)
      super.dispose(); // Limpa os callbacks registrados
    }
}---------------------------------
Conteúdo do arquivo: ./mundo/src/Utils/Time.ts
import EventEmitter from './EventEmitter';
import * as THREE from 'three';

export default class Time extends EventEmitter {
    start: number;
    current: number;
    elapsed: number;
    delta: number;
    private clock: THREE.Clock;

    constructor() {
        super();
        this.start = Date.now();
        this.current = this.start;
        this.elapsed = 0;
        this.delta = 16; // Default delta (approx 60fps)
        this.clock = new THREE.Clock();

        // Não chamamos tick() aqui, o Experience chamará no loop
    }

    tick(): void {
        const newCurrent = Date.now();
        this.delta = this.clock.getDelta(); // Usa THREE.Clock para delta mais preciso
        this.current = newCurrent;
        this.elapsed = this.current - this.start;

        this.trigger('tick'); // Emite o evento 'tick' a cada frame
    }

    dispose(): void {
      // Nada específico para limpar além dos callbacks
      super.dispose();
    }
}---------------------------------
Conteúdo do arquivo: ./mundo/src/Utils/EventEmitter.ts
type CallbackFunction = (...args: any[]) => void;

export default class EventEmitter {
    private callbacks: { [eventName: string]: { [callbackName: string]: CallbackFunction } } = {};
    private nextCallbackId: number = 0;

    on(eventName: string, callback: CallbackFunction): string {
        if (!this.callbacks[eventName]) {
            this.callbacks[eventName] = {};
        }
        const callbackName = `callback_${this.nextCallbackId++}`;
        this.callbacks[eventName][callbackName] = callback;
        return callbackName; // Retorna um ID para poder remover depois, se necessário
    }

    off(eventName: string, callbackName: string): void {
        if (this.callbacks[eventName] && this.callbacks[eventName][callbackName]) {
            delete this.callbacks[eventName][callbackName];
            if (Object.keys(this.callbacks[eventName]).length === 0) {
                delete this.callbacks[eventName];
            }
        }
    }

    trigger(eventName: string, ...args: any[]): void {
        if (this.callbacks[eventName]) {
            Object.values(this.callbacks[eventName]).forEach(callback => {
                try {
                    callback(...args);
                } catch (error) {
                    console.error(`Error in EventEmitter callback for event "${eventName}":`, error);
                }
            });
        }
    }

    dispose(): void {
      this.callbacks = {};
      this.nextCallbackId = 0;
    }
}---------------------------------
Conteúdo do arquivo: ./mundo/src/style.css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html,
body {
  overflow: hidden; /* Evita barras de rolagem */
}

#webgl {
  position: fixed;
  top: 0;
  left: 0;
  outline: none;
  /* Garante que o canvas esteja sob qualquer UI HTML que adicionarmos depois */
  z-index: -1; 
}---------------------------------
Conteúdo do arquivo: ./mundo/tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
---------------------------------
Conteúdo do arquivo: ./mundo/.gitignore
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
---------------------------------
Conteúdo do arquivo: ./mundo/package.json
{
  "name": "mundo",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite --host",
    "build": "tsc && vite build",
    "preview": "vite preview"
  },
  "devDependencies": {
    "@types/three": "^0.176.0",
    "typescript": "~5.7.2",
    "vite": "^6.3.1"
  },
  "dependencies": {
    "nipplejs": "^0.10.2",
    "three": "^0.176.0"
  }
}
---------------------------------
Conteúdo do arquivo: ./mundo/index.html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mundo - Three.js Project</title>
    <!-- Vamos adicionar nosso próprio CSS -->
    <link rel="stylesheet" href="/src/style.css">
  </head>
  <body>
    <!-- O Canvas onde a cena 3D será renderizada -->
    <canvas id="webgl"></canvas>

    <!-- Contêiner para o Joystick -->
    <div id="joystick-container" style="position: absolute; bottom: 50px; left: 50px; width: 150px; height: 150px; display: none; z-index: 20;">
        <!-- NippleJS irá popular este div -->
    </div>

    <!-- O ponto de entrada do nosso código TypeScript -->
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
---------------------------------
